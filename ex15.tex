\documentclass[a4paper,10pt]{article} %twocolumn
\usepackage[utf8]{inputenc} % letras acentuadas
\usepackage[portuguese]{babel} % tradução de títulos
\usepackage{algorithm} % ambiente para índice de algoritmos
\usepackage{algpseudocode} % fonte e estilo do algoritmo
\usepackage{tikz} % circuitos e automata
\usepackage{amsmath} % simbolos matematicos
%[noend]

\usetikzlibrary{automata,positioning}

\floatname{algorithm}{Algoritmo} % tradução da palavra algorítimo no ambiente de índice

\title{O algoritmo de conversão de Autômato Finito Não-Determinístico - AFND para Expressão Regular - ER}
\author{Eduardo Couto Dinarte,\\ Iago Gade Gusmao Carrazzoni}

\begin{document}

\maketitle

\begin{abstract}

    Este artigo consiste na apresenta\c{c}\~{a}o e explica\c{c}\~{a}o de um algoritmo para converter um aut\^{o}mato finito n\~{a}o determin\'{i}stico num aut\^{o}mato finito determin\'{i}stico e, por fim, converter este numa express\~{a}o regular. O m\'{e}todo consiste em apresentar a teoria com imagens dos tr\^{e}s estados da convers\~{a}o seguida de um exemplo pr\'{a}tico. O objetivo deste texto \'{e} fixar o conte\'{u}do de convers\~{a}o de aut\^{o}matos e familiarizar os autores com a produ\c{c}\~{a}o de artigos cient\'{i}ficos utilizando a linguagem Latex.

\end{abstract}


\section{Introdução aos Autômatos}

    Um autômato é uma máquina abstrata que deve operar entre estados previamente definidos. É um modelo matemático utilizado para representar programas ou circuitos lógicos. É bem definido por uma quíntupla, cujos elementos são:
    \begin{itemize}
        \item Conjunto de estados;
        \item alfabeto;
        \item estado inicial;
        \item conjunto de estados finais;
        \item função de transição (ou função delta).
    \end{itemize}

A função de transição, por sua vez, é representada por uma tripla ordenada, onde os elementos são:
    \begin{itemize}
        \item Estado inicial;
        \item transição;
        \item estado final;
    \end{itemize}

\section{Introdução ao AFND}

    Aut\^{o}mato finito n\~{a}o determin\'{i}stico \'{e} aquele em que, em algum momento, n\~{a}o se tem certeza de qual \'{e} o estado atual, ou seja, \'{e} aquele que tem a palavra vazia ligando algum de seus estados.

\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
   \node[state,initial] (q_0)   {$q_0$}; 
   \node[state] (q_1) [above right=of q_0] {$q_1$}; 
   \node[state] (q_2) [below right=of q_0] {$q_2$}; 
   \node[state,accepting](q_3) [below right=of q_1] {$q_3$};
   \node[state, accepting] (q_4) [right=of q_3] {$q_4$};
   \path[->]
       (q_0) edge node {$\epsilon$} (q_1)
             edge node [swap] {$\epsilon$} (q_2)
       (q_1) edge node {1} (q_3)
             edge [loop above] node {0} ()
       (q_2) edge node [swap] {0} (q_3)
             edge [loop below] node {1} ()
       (q_3) edge node {$\epsilon$} (q_4);
\end{tikzpicture}
\end{center}


\section{Introdução ao Autômato Finito Determinístico - AFD}

    Autômato finito determinístico é aquele em que se sabe exatamente qual o estado atual, ou seja, é aquele que não tem estados simultâneos ( estados ligados por palavras vazias).
    \begin{center}
    \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
        \node[state,initial] (q_0) {$q_0$};
        \node[state] (q_1) [above right=of q_0] {$q_1$};
        \node[state, accepting] (q_2) [right=of q_0] {$q_2$};
        \node[state] (q_3) [below right=of q_0] {$q_3$};
        \node[state] (q_4) [right=of q_1] {$q_4$};
        \node[state] (q_5) [below right=of q_2] {$q_5$};
        \node[state, accepting] (q_6) [below right=of q_4] {$q_6$};
        \path[->]
            (q_0) edge node {a} (q_1)
                  edge node {b} (q_2)
                  edge node {c} (q_3)
            (q_1) edge [loop above] node {a} ()
                  edge node {b} (q_4)
            (q_2) edge [loop above] node {c} ()
                  edge node {a} (q_4)
                  edge node {b} (q_5)
            (q_3) edge [loop below] node {b} ()
                  edge node {a} (q_5)
            (q_4) edge node {c} (q_6)
            (q_5) edge node {c} (q_6);
\end{tikzpicture}
\end{center}

\section{Introdução à ER}

    Expressão regular é uma cadeia de caracteres que engloba todas as palavras aceitas pelo autômato. Um autômato reduzido a expressão regular possui apenas um estado inicial e um estado final, ligados pela expressão regular.
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
    \node[state,initial] (q_0) {$q_0$};
    \node[state,accepting] [below right=of q_0] (q_1) {$q_1$};
    \path[->]
        (q_0) edge node {aa*(b {$\lor$} c)*} (q_1);
\end{tikzpicture}
\end{center}


    No tipo citado, é comum a aparição do caractere {$\lor$}, assim como o parêntese. Este se aplica da mesma forma que na matemática. Aquele é o conectivo lógico 'ou', que se aplica da mesma forma que na lógica.\\\\Também é comum a aparição do caractere '*' na expressão regular. Ele se chama estrela de Kleene, e denota zero ou mais repetições do caractere ( ou cadeia de caracteres ) ao qual foi aplicado.\\\\No exemplo acima, a estrela de Kleene foi aplicada ao caractere 'a' e à expressão (b {$\lor$} c). Neste, quer dizer que zero ou mais repetições da cadeia denotada serão aceitas, enquanto naquele, zero ou mais repetições do caractere denotado serão aceitos.


\section{Conversão de AFND para AFD}

    Para essa conversão, é utilizado o Algoritmo de Conversão de um Autômato Finito Não-determinístico (AFND) em um Autômato Finito Determinístico, que consiste em:
    \begin{itemize}
        \item Identificar os estados simultâneos do AFND;
        \item identificar o estado inicial P0, o qual seu conjunto possui apenas o estado inicial da AFND;
        \item aplicar em P0 a leitura de todo o alfabeto;
        \item Identificar os estados resultantes;
        \item para cada estado resultante criado, aplica-se o alfabeto;
        \item repetir o procedimento até que não existam mais estados novos;
        \item identificar os estados finais, que serão aqueles estados que possuírem os estados finais da AFND;     
        \item montar a quíntupla do AFD;     
        \item por fim, esboçar o grafo.    
    \end{itemize}
    Para exemplificar, será realizada a conversão do AFND a seguir:
    \begin{center}
        \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
            \node[state,initial] (q_0) {$q_0$};
            \node[state] [above right=of q_0](q_1) {$q_1$};
            \node[state] [below right=of q_0] (q_2) {$q_2$};
            \node[state,accepting] [right=of q_1] {$q_3$};
            \node[state,accepting] [above right=of q_5] {$q_4$};
            \node[state] [right=of q_2] (q_5) {$q_5$};
%            \path[->]
%                (q_0) edge node {$\epsilon$} (q_1)
%                      edge node {$\epsilon$} (q_2)
%                (q_1) edge node {b} (q_3)
%                      edge node {a} (q_5)
%                (q_2) edge node {a} (q_5)
%                (q_3) edge [loop above] node {a} ()
%                      edge node {c} (q_4)
%                (q_5) edge [loop below] node {c} ()
%                      edge node {b} (q_4);
            %\path[->]
            %    (q_0) edge node {$\epsilon$} (q_1)
            %          edge node [swap] {$\epsilon$} (q_2)
%
%                (q_1) edge node {b} (q_3)
%                      edge node {a} (q_5)
%
%                (q_2) edge node {a} (q_5)
%
%                (q_3) edge [loop above] node {a} ()
%                      edge node {c} (q_4)
%
%                (q_5) edge [loop below] node {c} ()
%                      edge node {b} (q_4);
        \end{tikzpicture}
    \end{center}

    Quíntupla da AFND:
    K = {0, 1, 2, 3, 4, 5}
    A = {a, b, c}
    S = {0, 1, 2}
    F = {3, 4}
    D =

    Seguindo o algoritmo, o procedimento será o seguinte:
    \begin{itemize}
        \item Identificar os estados simultâneos do AFND:
            E(0) = {0, 1, 2}
            E(1) = {1}
            E(2) = {2}
            E(3) = {3}
            E(4) = {4}
            E(5) = {5}
        \item identificar o estado inicial P0, o qual seu conjunto possui apenas o estado inicial da AFND:
            P0 = E(0) = {0, 1, 2}
        \item aplicar em P0 a leitura de todo o alfabeto:
            P0, a = (1, a, 5) U (2, a, 5) = E(5) = {5}
            P0, b = (1, b, 3) = E(3) = {3}
            P0, c = vazio
        \item Identificar os estados resultantes:
            P1 = P0, a = {5}
            P2 = P0, b = {3}
        \item para cada estado resultante criado, aplica-se o alfabeto:
            P1, a = vazio
            P1, b = (5, b, 4) = E(4) = {4}
            P1, c = (5, c, 5) = E(5) = {5}
            
            P2, a = (3, a, 3) = E(3) = {3}
            P2, b = vazio
            P2, c = (3, c, 4) = E(4) = {4}
        \item repetir o procedimento até que não existam mais estados novos:
            P1, b = P3 = {4}
            P1, c = P1 = {1}
            P2, a = P2 = {2}
            P2, c = P3 = {4}

            P3, a = vazio
            P3, b = vazio
            P3, c = vazio
        \item identificar os estados finais, que serão aqueles estados que possuírem os estados finais da AFND:
            F = {P2, P3}
        \item montar a quíntupla do AFD:
            K = {P0, P1, P2, P3}
            A = {a, b, c}
            S = {P0}
            F = {P2, P3}
            D =
        \item por fim, esboçar o grafo.    
    \end{itemize}

%\section{Implementação}
%
%Para conseguir blablabla
%
%
%
%O algoritmo \textit{Minimax} segue abaixo:
%
%\begin{algorithm}
%\caption{Algoritmo Minimax}\label{alg:minimax}
%\begin{algorithmic}[1]
%\Function{minimax}{estado}\Comment{retorna uma ação}
%\State \textbf{Entradas}: estado é a configuração atual do jogo
%\State $v\gets \mathrm{maxvalor}{(estado)}$
%\State \textbf{returna} a ação $a$ em sucessores(estado) cujo valor é $v$ %\Comment{comentario}
% \While{$r\not=0$}\Comment{We have the answer if r is 0}
% \State $a\gets b$
% \State $b\gets r$
% \State $r\gets a\bmod b$
% \EndWhile\label{euclidendwhile}
%\EndFunction
%\Function{maxvalor}{estado}\Comment{retorna o valor estático}
%\If{fim(estado)}
%   \State \textbf{retorna} estatico(estado)
%\EndIf
%\State $v \gets -\infty$
%\For{todas ações $a$ nos sucessores(estado)}
%    \State $v \gets \max{(v, \mathrm{minvalor}(a))}$
%\EndFor
%\State \textbf{retorna} $v$
%\EndFunction
%\Function{minvalor}{estado}\Comment{retorna o valor estático}
%\If{fim(estado)}
%   \State \textbf{retorna} estatico(estado)
%\EndIf
%\State $v \gets \infty$
%\For{todas ações $a$ nos sucessores(estado)}
%    \State $v \gets \min{(v, \mathrm{maxvalor}(a))}$
%\EndFor
%\State \textbf{retorna} $v$
%\EndFunction
%\end{algorithmic}
%\end{algorithm}


\end{document}
